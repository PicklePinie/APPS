//this code can solve radio station name with some I2C shit

// **************************************************************************
//
//               Demo program for labs
//
// Subject:      Computer Architectures and Parallel systems
// Author:       Petr Olivka, petr.olivka@vsb.cz, 08/2016
// Organization: Department of Computer Science, FEECS,
//               VSB-Technical University of Ostrava, CZ
//
// File:         Main programm for I2C bus
//
// **************************************************************************

#include <mbed.h>
  DigitalIn but9( PTC9 );
  DigitalIn but10( PTC10 );
  DigitalIn but11( PTC11 );
  DigitalIn but12( PTC12 );

#include "i2c-lib.h"
#include "si4735-lib.h"

//************************************************************************

// Direction of I2C communication
#define R	0b00000001
#define W	0b00000000

Serial pc( USBTX, USBRX );

#pragma GCC diagnostic ignored "-Wunused-but-set-variable"

class PCF{
public:
	PCF(unsigned char ADDRESS){
		this->address=ADDRESS;
	};
	void write(unsigned char VALUE){
		I2C_Start();
		uint8_t ack = 0;
		ack = I2C_Output( address | W );
		if(ack)
			printf("Nepodarilo se navazat spojeni\r\n");
		else
			printf("Spojeni uspesne navazano\r\n");
		ack = I2C_Output( VALUE );
		if(ack)
			printf("Nepodarilo se ulozit hodnotu\r\n");
		else
			printf("Hodnota uspesne ulozena: %d\r\n",VALUE);
		I2C_Stop();
	}

	void bar(unsigned char VALUE){
		unsigned char hodnota=1;
		if(VALUE>=0&&VALUE<=8)
		{
			hodnota = hodnota<<(VALUE-1);
			this->write(hodnota);
		}
		else
		{
			this->write(0);
		}
	}

	unsigned char read(){
		I2C_Start();
		uint8_t ack = 0;
		ack = I2C_Output( address | R );
		unsigned char vysledek=0b0;
		if(ack)
			printf("Nepodarilo se navazat spojeni\r\n");
		else
		{
			vysledek = I2C_Input();
			printf("Hodnota uspesne prectena: %d\r\n",vysledek);
		}

		I2C_Stop();
		return vysledek;
	}
	uint8_t address;
};

class RADIO{
public:
	RADIO(){};
	void setFreq(int freq2=0)
	{
		if(freq2)
			this->freq=freq2;
		I2C_Start();
		ack |= I2C_Output( SI4735_address | W );
		ack |= I2C_Output( 0x20 );			// FM_TUNE_FREQ
		ack |= I2C_Output( 0x00 );			// ARG1
		ack |= I2C_Output( freq2 >> 8 );		// ARG2 - FreqHi
		ack |= I2C_Output( freq2 & 0xff );	// ARG3 - FreqLo
		ack |= I2C_Output( 0x00 );			// ARG4
		I2C_Stop();
		printf( "Current set frequency: %d.%dMHz\r\n", freq / 100, freq % 100 );
	};

	void upFreq(int freq2=10)
	{
		this->freq+=freq2;
		this->setFreq();
	};

	void downFreq(int freq2=10)
	{
		this->freq-=freq2;
		this->setFreq();
	};

	int readFreq()
	{
		uint8_t S1, S2, RSSI, SNR, MULT, CAP;
		int freq3;
		I2C_Start();
		ack |= I2C_Output( SI4735_address | W );
		ack |= I2C_Output( 0x22 );			// FM_TUNE_STATUS
		ack |= I2C_Output( 0x00 );
		I2C_Start();
		// change direction of communication
		ack |= I2C_Output( SI4735_address | R );
		// read data
		S1 = I2C_Input();
		I2C_Ack();
		S2 = I2C_Input();
		I2C_Ack();
		freq3 = (int) I2C_Input() << 8;
		I2C_Ack();
		freq3 |= I2C_Input();
		I2C_Ack();
		RSSI = I2C_Input();
		I2C_Ack();
		SNR = I2C_Input();
		I2C_Ack();
		MULT = I2C_Input();
		I2C_Ack();
		CAP = I2C_Input();
		I2C_NAck();
		I2C_Stop();

		if ( ack != 0 )
			printf( "Communication error!\r\n" );
		else
			printf( "Current tuned frequency: %d.%dMHz\r\n", freq3 / 100, freq3 % 100 );
	};

	void setVolume(uint8_t VOLUME)
	{
		uint8_t S1, S2, RSSI, SNR, MULT, CAP;
		int freq3;
		I2C_Start();
		ack |= I2C_Output( SI4735_address | W );
		ack |= I2C_Output( 0x12 );
		ack |= I2C_Output( 0x00 );
		ack |= I2C_Output( 0x40 );
		ack |= I2C_Output( 0x00 );
		ack |= I2C_Output( 0x00 );
		ack |= I2C_Output( VOLUME );
		I2C_Stop();
	}

	void FM_SEEK_UP(){
		I2C_Start();
		ack |= I2C_Output( SI4735_address | W );
		ack |= I2C_Output( 0x21 );
		ack |= I2C_Output( 0b00000100 |1<<3);
		I2C_Stop();
		if ( ack != 0 )
			printf( "Communication error!\r\n" );
		else
			printf( "Frekvence vyhledana nahoru\r\n");
	}

	void FM_SEEK_DOWN(){
		I2C_Start();
		ack |= I2C_Output( SI4735_address | W );
		ack |= I2C_Output( 0x21 );
		ack |= I2C_Output( 0b00000100);
		I2C_Stop();
		if ( ack != 0 )
			printf( "Communication error!\r\n" );
		else
			printf( "Frekvence vyhledana dolu\r\n");
	}

	int freq = 10140;
	uint8_t ack = 0;
};

int main( void )
{
	uint8_t S1, S2, RSSI, SNR, MULT, CAP;
	uint8_t ack = 0;

	I2C_Init();

	pc.baud( 115200 );
	pc.printf( "K64F-KIT ready...\r\n" );

	// communication with 8 bit expander PCF8574

	// start communication
	//I2C_Start();

	// PCF8574 addressing
	// The address is composed from 3 parts!
	//ack = I2C_Output( PCF8574 );

	// Check ack! Return value must be 0!
	// ....
	PCF PCF1(0b01001010);

	PCF1.bar(1);
	PCF1.bar(3);
	PCF1.bar(-10);
	PCF1.bar(7);
	ack = PCF1.read();



	//ack = I2C_Output( 0b01010110 );
	// selected LEDs should light

	// stop communication
	//I2C_Stop();

//	if ( ( ack = SI4735_Init() ) != 0 )
//	{
//		pc.printf( "Initialization of SI4735 finish with error (%d)\r\n", ack );
//		return 0;
//	}
//	else
//		pc.printf( "SI4735 initialized.\r\n" );
//
//	pc.printf( "\nTunig of radio station...\r\n" );
	
	// Required frequency in MHz * 100
	//int freq = 10140; // Radiozurnal

	// Tuning of radio station
//	I2C_Start();
//	ack |= I2C_Output( SI4735_address | W );
//	ack |= I2C_Output( 0x20 );			// FM_TUNE_FREQ
//	ack |= I2C_Output( 0x00 );			// ARG1
//	ack |= I2C_Output( freq >> 8 );		// ARG2 - FreqHi
//	ack |= I2C_Output( freq & 0xff );	// ARG3 - FreqLo
//	ack |= I2C_Output( 0x00 );			// ARG4
//	I2C_Stop();
	// Check ack!
	// if...
	
	// Tuning process inside SI4735
//	wait_ms( 100 );
//	printf( "... station tuned.\r\n\n" );
	
	// Example of reading of tuned frequency
//	I2C_Start();
//	ack |= I2C_Output( SI4735_address | W );
//	ack |= I2C_Output( 0x22 );			// FM_TUNE_STATUS
//	ack |= I2C_Output( 0x00 );			// ARG1
	// repeated start
//	I2C_Start();
//	// change direction of communication
//	ack |= I2C_Output( SI4735_address | R );
//	// read data
//	S1 = I2C_Input();
//	I2C_Ack();
//	S2 = I2C_Input();
//	I2C_Ack();
//	freq = (int) I2C_Input() << 8;
//	I2C_Ack();
//	freq |= I2C_Input();
//	I2C_Ack();
//	RSSI = I2C_Input();
//	I2C_Ack();
//	SNR = I2C_Input();
//	I2C_Ack();
//	MULT = I2C_Input();
//	I2C_Ack();
//	CAP = I2C_Input();
//	I2C_NAck();
//	I2C_Stop();
//
//	if ( ack != 0 )
//		printf( "Communication error!\r\n" );
//	else
//		printf( "Current tuned frequency: %d.%dMHz\r\n", freq / 100, freq % 100 );

	//PCF1.bar2();
	int Volume=30;
	int RegVolumeBy=10;
	RADIO *RADIO1 = new RADIO();
	RADIO1->setFreq();
	RADIO1->setVolume(Volume);

	bool pressed9 = false,pressed10 = false,pressed11 = false,pressed12 = false;
	while(true)
	{
		wait_ms(5);
		if(!pressed9&&!but9)
		{
			RADIO1->FM_SEEK_DOWN();
			pressed9 = true;
		}
		else if(but9&&pressed9)
		{
			RADIO1->readFreq();
			pressed9 = false;
		}

		if(!pressed10&&!but10)
		{
			RADIO1->FM_SEEK_UP();
			pressed10 = true;
		}
		else if(but10&&pressed10)
		{
			RADIO1->readFreq();
			pressed10 = false;
		}
		if(!pressed11&&!but11)
		{
			if(Volume+RegVolumeBy>63)
				Volume=63;
			else
				Volume+=RegVolumeBy;
			RADIO1->setVolume(Volume);
			pressed11 = true;
		}
		else if(but11&&pressed11)
		{
			pressed11 = false;
		}
		if(!pressed12&&!but12)
		{
			if(Volume-RegVolumeBy<0)
				Volume=0;
			else
				Volume-=RegVolumeBy;
			RADIO1->setVolume(Volume);
			pressed12 = true;
		}
		else if(but12&&pressed12)
		{
			pressed12 = false;
		}
	}

	return 0;
}


//this is another code for another lecture with I2C
 
 
// **************************************************************************
//
//               Demo program for labs
//
// Subject:      Computer Architectures and Parallel systems
// Author:       Petr Olivka, petr.olivka@vsb.cz, 08/2016
// Organization: Department of Computer Science, FEECS,
//               VSB-Technical University of Ostrava, CZ
//
// File:         Main programm for I2C bus
//
// **************************************************************************
 
#include <mbed.h>
#include <string>
 
#include "i2c-lib.h"
#include "si4735-lib.h"
#include <bitset>
 
//************************************************************************
 
// Direction of I2C communication
#define R   0b00000001
#define W   0b00000000
 
Serial pc( USBTX, USBRX );
 
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 
void changeVolume(int volume){
    uint8_t ack = 0;
    I2C_Start();
    ack |= I2C_Output(SI4735_address | W);
    ack |= I2C_Output(0x12);
    ack |= I2C_Output(0x00);
    ack |= I2C_Output(0x40);
    ack |= I2C_Output(0x00);
    ack |= I2C_Output(0x00);
    ack |= I2C_Output(volume);
    I2C_Stop();
}
 
void showVolume(uint8_t volume)
 
{
    uint8_t newVolume = 0;
 
    for(int i = 0; i < volume; i++)
    {
        newVolume |= 1 << i;
    }
 
    uint8_t ack = 0;
    // start communication
    I2C_Start();
 
    // PCF8574 addressing
    // The address is composed from 3 parts!
    ack = I2C_Output( 0100 | 000 | W );
 
    // Check ack! Return value must be 0!
    // ....
 
    ack = I2C_Output(newVolume);
    // selected LEDs should light
 
    // stop communication
    I2C_Stop();
}
 
string getStationName(){
    char nazevStanice [8];
    for(int i = 0; i < 8; i++){
        nazevStanice[i] = (char)0;
    }
    bool isComplete;
    while(true)
    {
        uint8_t RDS0, RDS1, Sync, RDS3, B1HI, B1LO, B2HI, B2LO, B3HI, B3LO, B4HI, B4LO, status;
        uint8_t ack = 0;
        isComplete = true;
        while(true){
            I2C_Start();
            ack |= I2C_Output( SI4735_address | W );
            ack |= I2C_Output( 0x24 );
            ack |= I2C_Output( 1 );
            // repeated start
            I2C_Start();
            ack |= I2C_Output( SI4735_address | R );
            RDS0 = I2C_Input();         //nacitame 1 bajt (8 bitov) do premennej RDS0
            I2C_Ack();                  //vysleme potvrdzovaci bit, aby system vedel, ze bajt sme uspesne precitali (vid strana 29 - address verification)
            RDS1 = I2C_Input();         //nacitame dalsi bajt do premennej RDS1
            I2C_Ack();                  //znova vysleme potvrdzovaci bit
            Sync = I2C_Input() & 1;
            I2C_Ack();
            RDS3 = I2C_Input();
            I2C_Ack();
            B1HI = I2C_Input();
            I2C_Ack();
            B1LO = I2C_Input();
            I2C_Ack();
            B2HI = I2C_Input();
            I2C_Ack();
            if((B2HI & 0xF800)>>11 == 1 || (B2HI & 0xF800)>>11 == 0){
                break;
            }
            //int buffer = I2C_Input();
            I2C_NAck();
            I2C_Stop();
        }
        B2LO = I2C_Input();
        I2C_Ack();
        B3HI = I2C_Input();
        I2C_Ack();
        B3LO = I2C_Input();
        I2C_Ack();
        B4HI = I2C_Input();
        I2C_Ack();
        B4LO = I2C_Input();
        I2C_Ack();
        status = I2C_Input();
        I2C_NAck();         //ako potvrdzovaci bit posleme negovany ACK, teda sme ukoncili citanie
        I2C_Stop();         //ukoncenie komunikacie
        int blok2 = B2HI<<8 | B2LO;
        /*
        int blok3 = B3HI<<8 | B3LO;
        int blok4 = B4HI<<8 | B4LO;
        */
        int poziceZnaku = blok2 &3;
        nazevStanice[(poziceZnaku*2)] = (char)B4HI;
        nazevStanice[(poziceZnaku*2)+1] = (char)B4LO;
        for(int i = 0; i < 8; i++){
            if((int) nazevStanice[i] == 0){
                isComplete = false;
                break;
            }
        }
        if (isComplete){
            break;
        }
    }
    string stationName;
    for(int i = 0; i < 8; i++){
        stationName += (char)nazevStanice[i];
    }
    return stationName;
}
 
void readBasicRDS(){
    uint8_t RDS0, RDS1, Sync, RDS3, B1HI, B1LO, B2HI, B2LO, B3HI, B3LO, B4HI, B4LO, status;     //nadefinujeme si premenne, ktore budeme nacitavat
    uint8_t ack = 0;
    I2C_Start();                                //zaciatok komunikacie
    ack |= I2C_Output( SI4735_address | W );    //zaadresovanie radioveho modulu (W - zapis, zapiseme dotaz na vydanie RDS sprav)
    ack |= I2C_Output( 0x24 );                  // FM_RDS_STATUS
    ack |= I2C_Output( 1 );                     // argument, ktory vyziada vnutorne prerusenie pre prijem RDS dat
    // repeated start
    I2C_Start();                                //znovu zopakujeme zaciatok komunikacie
    /*Nasleduje zmena smeru komunikacie (R - citame odpoved na vyssie zadany dotaz 0x24, vid dokumentacia str 36 apps_labexc.pdf
     * potom dostaneme odpoved vo forme 13 bajtov, ktore nasledne postupne nacitame do premennych deklarovanyych na zaciatku tejto funkcie
     * zoznam premennych a poradie, v ktorom ich nacitame je na strane 36
     */
    ack |= I2C_Output( SI4735_address | R );    //vysleme na vystup adresu radia a ziadost o citanie
    RDS0 = I2C_Input();         //nacitame 1 bajt (8 bitov) do premennej RDS0
    I2C_Ack();                  //vysleme potvrdzovaci bit, aby system vedel, ze bajt sme uspesne precitali (vid strana 29 - address verification)
    RDS1 = I2C_Input();         //nacitame dalsi bajt do premennej RDS1
    I2C_Ack();                  //znova vysleme potvrdzovaci bit
    /*teraz nacitame bajt v ktorom nas zaujima len bit s najnizsou vahou, ktory nam povie, ci su data synchronizovane, alebo nie (strana 36)
     * nie som si isty, ci 1 znamena ano synchronizovane, alebo nie nesychnronizovane
     * potom staci prerobit podmienku vid nizsie if(Sync == 0) na 1
     * jeden bit nacitame tak, ze cely nacitany bajt vymaskujeme jednotkou (binarne 0b00000001) teda bitovy AND
     * bit som si oznacil ako Sync
     */
    Sync = I2C_Input() & 1;
    I2C_Ack();
    if(Sync == 0){          //ak data nie su synchronizovane, netreba data dalej citat, mozeme vypisat do konzoly infromaciu a ukoncit nacitavanie (zakomentovane return)
        printf("RDS informace nejsou synchronizovany");
        //return;
    }
    RDS3 = I2C_Input();
    I2C_Ack();
    /* Nasleduje nacitavanie 4x2 polovice blokov oznacenych ako B1HI (high) a B1LO (low), ktore nesu jednotlive RDS informacie
     * strana 36 - response, bajty 4-11
     */
    B1HI = I2C_Input();
    I2C_Ack();
    B1LO = I2C_Input();
    I2C_Ack();
    B2HI = I2C_Input();
    I2C_Ack();
    B2LO = I2C_Input();
    I2C_Ack();
    B3HI = I2C_Input();
    I2C_Ack();
    B3LO = I2C_Input();
    I2C_Ack();
    B4HI = I2C_Input();
    I2C_Ack();
    B4LO = I2C_Input();
    I2C_Ack();
    status = I2C_Input();
    I2C_NAck();         //ako potvrdzovaci bit posleme negovany ACK, teda sme ukoncili citanie
    I2C_Stop();         //ukoncenie komunikacie
 
/* teraz si jednotlive polovice blokov (2x8bitov) spojime do jedneho 16 bitoveho cisla
 * HI polovicu posunieme o 8 bitov dolava, tj nam vpravo od nich vznikne 8 "prazdnych" pozicii, kam bitovym ORom "pripojime" LO polovicu
 */
    int blok1 = B1HI<<8 | B1LO;         //obsahuje cislo stanice - program identification
    int blok2 = B2HI<<8 | B2LO;         //obsahuje cislo skupiny, verziu skupiny(A alebo B), info ci sa vysielaju dopravne informacie, typ vysielaneho programu
    /*blok 3 v zavislosti od skupiny obsahuje: (strany 36-38)
     * skupina 0A - alternativne frekvencie
     * skupina 0B - PI code - neporozumel som, preco znova, ked sa vysiela aj v prvom bloku
     * skupina 2A - radiotext prva dvojica
     */
    int blok3 = B3HI<<8 | B3LO;
    /*blok 4 v zavislosti od skupiny obsahuje:  (strany 36-38)
         * skupina 0A - nazov stanice
         * skupina 0B - nazov stanice
         * skupina 2A - radiotext druha dvojica
         */
    int blok4 = B4HI<<8 | B4LO;
 
    printf("Identifikacia stanice: %d\r\n", blok1);     //vypiseme cislo stanice
 
}
 
int main( void )
{
    DigitalIn butDown(PTC9);
    DigitalIn butUp(PTC10);
    DigitalIn RDSinfo(PTC11);
    uint8_t S1, S2, RSSI, SNR, MULT, CAP;
    uint8_t ack = 0;
 
    I2C_Init();
 
    pc.baud( 115200 );
    pc.printf( "K64F-KIT ready...\r\n" );
 
    // communication with 8 bit expander PCF8574
 
    // start communication
    //I2C_Start();
 
    // PCF8574 addressing
    // The address is composed from 3 parts!
    //ack = I2C_Output( HWADR_PCF8574 | A012 | W );
 
    // Check ack! Return value must be 0!
    // ....
 
    //ack = I2C_Output( Any_8_bit_value );
    // selected LEDs should light
 
    // stop communication
    //I2C_Stop();
 
    if ( ( ack = SI4735_Init() ) != 0 )
    {
        pc.printf( "Initialization of SI4735 finish with error (%d)\r\n", ack );
        return 0;
    }
    else
        pc.printf( "SI4735 initialized.\r\n" );
 
    pc.printf( "\nTunig of radio station...\r\n" );
 
    // Required frequency in MHz * 100
    int freq = 10000;
 
    // Tuning of radio station
    I2C_Start();
    ack |= I2C_Output( SI4735_address | W );
    ack |= I2C_Output( 0x20 );          // FM_TUNE_FREQ
    ack |= I2C_Output( 0x00 );          // ARG1
    ack |= I2C_Output( freq >> 8 );     // ARG2 - FreqHi
    ack |= I2C_Output( freq & 0xff );   // ARG3 - FreqLo
    ack |= I2C_Output( 0x00 );          // ARG4
    I2C_Stop();
    // Check ack!
 
    /*
    int volume = 5;
        while(true){
            if(butUp == false){         //PTC9
                while(butUp == false){
                }
                if(volume < 8) {
                    volume++;
                }
                else {
                    volume = 8;
                }
            }
            if(butDown == false){       //PTC10
                while(butDown == false){
                }
                if(volume > 0) {
                    volume--;
                }
                else {
                    volume = 0;
                }
 
            }
 
            changeVolume(volume*7);
            showVolume(volume);
        }
    // Tuning process inside SI4735
    wait_ms( 100 );
    printf( "... station tuned.\r\n\n" );
 
    // Example of reading of tuned frequency
    I2C_Start();
    ack |= I2C_Output( SI4735_address | W );
    ack |= I2C_Output( 0x22 );          // FM_TUNE_STATUS
    ack |= I2C_Output( 0x00 );          // ARG1
    // repeated start
    I2C_Start();
    // change direction of communication
    ack |= I2C_Output( SI4735_address | R );
    // read data
    S1 = I2C_Input();
    I2C_Ack();
    S2 = I2C_Input();
    I2C_Ack();
    freq = (int) I2C_Input() << 8;
    I2C_Ack();
    freq |= I2C_Input();
    I2C_Ack();
    RSSI = I2C_Input();
    I2C_Ack();
    SNR = I2C_Input();
    I2C_Ack();
    MULT = I2C_Input();
    I2C_Ack();
    CAP = I2C_Input();
    I2C_NAck();
    I2C_Stop();
 
    */
 
    while(true){
    if(!RDSinfo){
        while(RDSinfo == false){
        }
        readBasicRDS();     //zavolani funkce na cteni RDS
    }
    string getStationName();
    }
    string getStationName();
 
 
 
    if ( ack != 0 )
        printf( "Communication error!\r\n" );
    else
        printf( "Current tuned frequency: %d.%dMHz\r\n", freq / 100, freq % 100 );
 
    return 0;
 
}


//Cviko z 23.10. dostal jsem za to 5 bodů, ale měl vítku k getRDS, že prý jsem z toho udělal getPSzRDS, neboli jako argument metody by mohla být maska
//která by u B2HI ověřovala co chceme, v případě PS to jsou vrchní 4 bity nuly
// jestli to budete kopírovat, tak nahradte v tom PS poli to podtržítko (v ASCII to je 95) za něco jiného, S. by to poznal..

#include <mbed.h>
DigitalIn but9( PTC9 );
DigitalIn but10( PTC10 );
DigitalIn but11( PTC11 );
DigitalIn but12( PTC12 );
 
#include \"i2c-lib.h\"
#include \"si4735-lib.h\"
 
//************************************************************************
 
// Direction of I2C communication
#define R   0b00000001
#define W   0b00000000
 
Serial pc( USBTX, USBRX );
 
#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"
 
class PCF{
public:
    PCF(unsigned char ADDRESS){
        this->address=ADDRESS;
    };
    void write(unsigned char VALUE){
        I2C_Start();
        uint8_t ack = 0;
        ack = I2C_Output( address | W );
        if(ack)
            printf(\"Nepodarilo se navazat spojeni\\r\\n\");
        else
            printf(\"Spojeni uspesne navazano\\r\\n\");
        ack = I2C_Output( VALUE );
        if(ack)
            printf(\"Nepodarilo se ulozit hodnotu\\r\\n\");
        else
            printf(\"Hodnota uspesne ulozena: %d\\r\\n\",VALUE);
        I2C_Stop();
    }
 
    //Moje hracka
    void bar2(){
 
        unsigned char bar=1;
        bool up = true;
        while(true)
        {
            this->write(bar);
            if(up)
                bar=bar+bar+1;
            else
                bar=bar/2;
            if(bar==255)
                up=false;
            if(bar==1)
            {
                wait_ms(200);
                this->write(bar);
                break;
            }
            wait_ms(200);
        }
        //1 = 1. ledka, 3 = 3. ledka
    }
 
    void bar(unsigned char VALUE){
        unsigned char hodnota=1;
        if(VALUE>=0&&VALUE<=8)
        {
            hodnota = hodnota<<(VALUE-1);
            this->write(hodnota);
        }
        else
        {
            this->write(0);
        }
    }
 
    unsigned char read(){
        I2C_Start();
        uint8_t ack = 0;
        ack = I2C_Output( address | R );
        unsigned char vysledek=0b0;
        if(ack)
            printf(\"Nepodarilo se navazat spojeni\\r\\n\");
        else
        {
            vysledek = I2C_Input();
            printf(\"Hodnota uspesne prectena: %d\\r\\n\",vysledek);
        }
 
        I2C_Stop();
        return vysledek;
    }
    uint8_t address;
};
 
class RADIO{
public:
    RADIO(){
        for(int i= 0;i<8;i++)
            PS[i]=95;
    };
    void setFreq(int freq2=0)
    {
        if(freq2)
            this->freq=freq2;
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x20 );          // FM_TUNE_FREQ
        ack |= I2C_Output( 0x00 );          // ARG1
        ack |= I2C_Output( freq2 >> 8 );      // ARG2 - FreqHi
        ack |= I2C_Output( freq2 & 0xff );  // ARG3 - FreqLo
        ack |= I2C_Output( 0x00 );          // ARG4
        I2C_Stop();
        printf( \"Current set frequency: %d.%dMHz\\r\\n\", freq / 100, freq % 100 );
    };
 
    void clearPS(){
        for(int i= 0;i<8;i++)
            PS[i]=95;
    }
 
    void upFreq(int freq2=10)
    {
        this->freq+=freq2;
        this->setFreq();
    };
 
    void downFreq(int freq2=10)
    {
        this->freq-=freq2;
        this->setFreq();
    };
 
    //B2 vrchní 4 bity - zjistíme co nám posílá (potřebujeme program service) 5 bit z leva je A nebo B při PS to je jedno jestli A nebo B
    //4 bity na nule je PS, B4 obsahuje 2 písmenka
    //B2 poslední 2 bity zjistíme které 2 písmena jsme dostali
 
    void readFreq()
    {
        uint8_t S1, S2, RSSI, SNR, MULT, CAP;
        int freq3;
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x22 );          // FM_TUNE_STATUS
        ack |= I2C_Output( 0x00 );
        I2C_Start();
        // change direction of communication
        ack |= I2C_Output( SI4735_address | R );
        // read data
        S1 = I2C_Input();
        I2C_Ack();
        S2 = I2C_Input();
        I2C_Ack();
        freq3 = (int) I2C_Input() << 8;
        I2C_Ack();
        freq3 |= I2C_Input();
        I2C_Ack();
        RSSI = I2C_Input();
        I2C_Ack();
        SNR = I2C_Input();
        I2C_Ack();
        MULT = I2C_Input();
        I2C_Ack();
        CAP = I2C_Input();
        I2C_NAck();
        I2C_Stop();
 
        if ( ack != 0 )
            printf( \"Communication error!\\r\\n\" );
        else
            printf( \"Current tuned frequency: %d.%dMHz\\r\\n\", freq3 / 100, freq3 % 100 );
    };
 
    void setVolume(uint8_t VOLUME)
    {
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x12 );
        ack |= I2C_Output( 0x00 );
        ack |= I2C_Output( 0x40 );
        ack |= I2C_Output( 0x00 );
        ack |= I2C_Output( 0x00 );
        ack |= I2C_Output( VOLUME );
        I2C_Stop();
    }
 
    void FM_SEEK_UP(){
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x21 );
        ack |= I2C_Output( 0b00000100 |1<<3);
        I2C_Stop();
        if ( ack != 0 )
            printf( \"Communication error!\\r\\n\" );
        else
            printf( \"Frekvence vyhledana nahoru\\r\\n\");
    }
 
    void FM_SEEK_DOWN(){
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x21 );
        ack |= I2C_Output( 0b00000100);
        I2C_Stop();
        if ( ack != 0 )
            printf( \"Communication error!\\r\\n\" );
        else
            printf( \"Frekvence vyhledana dolu\\r\\n\");
    }
 
    void getRDS(){
        uint8_t RDS0, RDS1, Sync, RDS3, B1HI, B1LO, B2HI, B2LO, B3HI, B3LO, B4HI, B4LO, status, ack = 0;
        uint16_t B1, B2, B3, B4;
        I2C_Start();
        ack |= I2C_Output( SI4735_address | W );
        ack |= I2C_Output( 0x24 );
        ack |= I2C_Output( 1);
        if ( ack != 0 )
            printf( \"Communication error!\\r\\n\" );
        I2C_Start();
        ack |= I2C_Output( SI4735_address | R );
        RDS0 = I2C_Input();
        I2C_Ack();
        RDS1 = I2C_Input();
        I2C_Ack();
        Sync = I2C_Input() & 1; //Dostatečně silný signál?
        if(!Sync)
        {
            I2C_NAck();
            I2C_Stop();
            return;
        }
        I2C_Ack();
        RDS3 = I2C_Input();
        I2C_Ack();
        B1HI = I2C_Input();
        I2C_Ack();
        B1LO = I2C_Input();
        I2C_Ack();
        B2HI = I2C_Input();
        if(B2HI>>4)   //Dostáváme PS?
        {
            I2C_NAck();
            I2C_Stop();
            return;
        }
        I2C_Ack();
        B2LO = I2C_Input();
        I2C_Ack();
        B3HI = I2C_Input();
        I2C_Ack();
        B3LO = I2C_Input();
        I2C_Ack();
        B4HI = I2C_Input();
        I2C_Ack();
        B4LO = I2C_Input();
        I2C_Ack();
        status = I2C_Input();
        I2C_NAck();
        I2C_Stop();
 
 
         
 
//      0 - 1+2 [0;1]
//      1 - 3+4 [2;3]
//      2 - 5+6 [4;5]
//      3 - 7+8 [6;7]
        int Pozice = B2LO&3;
        PS[(Pozice*2)]=(char)B4HI;
        PS[(Pozice*2)+1]=(char)B4LO;
 
    }
 
    void getPS()
    {
        for(int i=0;i<8;i++)
        {
            printf(\"%c\",PS[i]);
        }
        printf(\"\\r\\n\");
    }
 
    bool IsPSComplete()
    {
        for(int i=0;i<8;i++)
        {
            if(PS[i]==95)
                return false;
        }
        return true;
    }
 
    int freq = 10140;
    uint8_t ack = 0;
    char PS[8];
 
    // up frek
    // down frek
    // volume
    // dej frekvenci
};
 
int main( void )
{
    uint8_t ack = 0;
 
    I2C_Init();
 
    pc.baud( 115200 );
    pc.printf( \"K64F-KIT ready...\\r\\n\" );
 
    // communication with 8 bit expander PCF8574
 
    // start communication
    //I2C_Start();
 
    // PCF8574 addressing
    // The address is composed from 3 parts!
    //ack = I2C_Output( PCF8574 );
 
    // Check ack! Return value must be 0!
    // ....
    PCF PCF1(0b01001010);
 
    PCF1.bar(1);
    PCF1.bar(3);
    PCF1.bar(-10);
    PCF1.bar(7);
    ack = PCF1.read();
 
 
 
    //ack = I2C_Output( 0b01010110 );
    // selected LEDs should light
 
    // stop communication
    //I2C_Stop();
 
//  if ( ( ack = SI4735_Init() ) != 0 )
//  {
//      pc.printf( \"Initialization of SI4735 finish with error (%d)\\r\\n\", ack );
//      return 0;
//  }
//  else
//      pc.printf( \"SI4735 initialized.\\r\\n\" );
//
//  pc.printf( \"\\nTunig of radio station...\\r\\n\" );
     
    // Required frequency in MHz * 100
    //int freq = 10140; // Radiozurnal
 
    // Tuning of radio station
//  I2C_Start();
//  ack |= I2C_Output( SI4735_address | W );
//  ack |= I2C_Output( 0x20 );          // FM_TUNE_FREQ
//  ack |= I2C_Output( 0x00 );          // ARG1
//  ack |= I2C_Output( freq >> 8 );       // ARG2 - FreqHi
//  ack |= I2C_Output( freq & 0xff );   // ARG3 - FreqLo
//  ack |= I2C_Output( 0x00 );          // ARG4
//  I2C_Stop();
    // Check ack!
    // if...
     
    // Tuning process inside SI4735
//  wait_ms( 100 );
//  printf( \"... station tuned.\\r\\n\\n\" );
     
    // Example of reading of tuned frequency
//  I2C_Start();
//  ack |= I2C_Output( SI4735_address | W );
//  ack |= I2C_Output( 0x22 );          // FM_TUNE_STATUS
//  ack |= I2C_Output( 0x00 );          // ARG1
    // repeated start
//  I2C_Start();
//  // change direction of communication
//  ack |= I2C_Output( SI4735_address | R );
//  // read data
//  S1 = I2C_Input();
//  I2C_Ack();
//  S2 = I2C_Input();
//  I2C_Ack();
//  freq = (int) I2C_Input() << 8;
//  I2C_Ack();
//  freq |= I2C_Input();
//  I2C_Ack();
//  RSSI = I2C_Input();
//  I2C_Ack();
//  SNR = I2C_Input();
//  I2C_Ack();
//  MULT = I2C_Input();
//  I2C_Ack();
//  CAP = I2C_Input();
//  I2C_NAck();
//  I2C_Stop();
//
//  if ( ack != 0 )
//      printf( \"Communication error!\\r\\n\" );
//  else
//      printf( \"Current tuned frequency: %d.%dMHz\\r\\n\", freq / 100, freq % 100 );
 
    //PCF1.bar2();
    int Volume=30;
    int RegVolumeBy=10;
    RADIO *RADIO1 = new RADIO();
    RADIO1->setFreq();
    RADIO1->setVolume(Volume);
 
 
 
    bool pressed9 = false,pressed10 = false,pressed11 = false,pressed12 = false;
    while(true)
    {
        wait_ms(5);
        if(!pressed9&&!but9)
        {
            RADIO1->FM_SEEK_DOWN();
            pressed9 = true;
        }
        else if(but9&&pressed9)
        {
            RADIO1->readFreq();
            pressed9 = false;
        }
 
        if(!pressed10&&!but10)
        {
            RADIO1->FM_SEEK_UP();
            pressed10 = true;
        }
        else if(but10&&pressed10)
        {
            RADIO1->readFreq();
            pressed10 = false;
        }
        if(!pressed11&&!but11)
        {
            if(Volume+RegVolumeBy>63)
                Volume=63;
            else
                Volume+=RegVolumeBy;
            RADIO1->setVolume(Volume);
            pressed11 = true;
        }
        else if(but11&&pressed11)
        {
            pressed11 = false;
        }
        if(!pressed12&&!but12)
        {
            if(Volume-RegVolumeBy<0)
                Volume=0;
            else
                Volume-=RegVolumeBy;
            RADIO1->setVolume(Volume);
            pressed12 = true;
        }
        else if(but12&&pressed12)
        {
            RADIO1->clearPS();
            while(!RADIO1->IsPSComplete())
            {
                RADIO1->getRDS();
                RADIO1->getPS();
            }
            pressed12 = false;
        }
    }
 
    return 0;
}
